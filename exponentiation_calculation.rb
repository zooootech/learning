# べき乗の計算 (paizaランク C 相当)
# https://paiza.jp/works/mondai/a_rank_level_up_problems/a_rank_calculation_step2

# 素直に * 2 を繰り返し行おうとすると、最大 10^12 回ループが回ることになってしまい、 実行制限時間に間に合いません。
# そこで、 繰り返し二乗法 というアルゴリズムを使います。
# このアルゴリズムは、 2 ^ N を、 2 ^ (2 ^ i) 乗を用いて表すことで計算量を O(logN) に落とすアルゴリズムです。
# まず N の ２ 進数表現を考えます。Nの最下位の桁が １ かどうかを確認します。
# 最下位の桁が １ の場合、 2 の i 乗である pow を ans にかけます。
# この処理が終わったら、pow を pow の ２ 乗に置き換え、N を右に １ ビットシフト(割る 2)します。
# これを繰り返すことで、i 回目のときに、2 ^ i のかけ算を行うことができます。

# -------------------------------------------------

n = gets.to_i

# pow(other, modulo) は self の冪(べき乗)を計算します。
# other は二項演算の右側の対象(右項のこと、 2 ** 3 の 3 の部分で、「指数」とも言える)になる引数
# modulo を指定すると、計算途中に巨大な値を生成せずに (self**other) % modulo と同じ結果を返します。
num = 2.pow(n, 1000003)

puts num

# -------------------------------------------------

# 繰り返し二乗法による解法

n = gets.to_i
m = 1000003
i = 2
ans = 1

while 0 < n

  # self & other の & はビット二項演算子。論理積を計算します。 other は数値。
  # &(ビットAND) は演算子の左辺と右辺の同じ位置にあるビットを比較して、両方のビットが共に「1」の場合だけ「1」にします。
  # ここでは、n の 2 進数の最下位ビット（最下位の桁）が 1 のとき、 if 以下の処理を行う
  if n & 1 == 1
    ans = ans * i % m
  end

  i = i * i % m

  # >>= は、シフト演算子 >> の自己代入演算子
  # シフト演算子はビット演算子と同じく対象の値を 2 進数のビットとして考え、ビットを左又は右へシフトさせます。
  # 2 進数は，各桁を 0 か 1 かで表す表記法であり，その各桁をビットとも呼ぶ
  # なお 2 進数において左へ 1 つビットをシフトさせることは値を 2 倍することに相当し、右へ 1 つビットをシフトさせることは値を 1 / 2 にすることに相当します。
  # n >> 1 のように、論理シフトを用いて n を右に 1 ビットシフトさせると n / 2 の値が得られる
  # n を 2 進数で表したときに、各桁（ビット）が 1 かどうかを検証するために、ここで n に対し右に 1 つ論理シフトを行う
  n >>= 1
end

puts ans


# ちなみに、ビット演算を用いると、論理積を用いて偶数奇数を判定することができる
# n & 1 == 1 は n が奇数のとき true を返し、例えば n & 1 == 0 は n が偶数のとき true を返す

# -------------------------------------------------

# 以下のコードだと n が大きすぎた場合に出力される数値が NaN(Not a number) になる

n = get.to_i

# ** は算術演算子。冪(べき乗)を計算します。
num = 2 ** n

puts num % 1000003

# -------------------------------------------------

# 以下のコードだとタイムオーバーになる

n = gets.to_i

numbers = Array.new(n, 2)

sum = 1
numbers.each do |i|
  sum *= i
end

puts sum % 1000003

# -------------------------------------------------

# 以下、試用のコード

n = gets.to_i
m = 1000003
i = 2
ans = 1

while 0 < n
  if n & 1 == 1
    ans = ans * i % m
    p "あ"
    p "nは#{n}"
    p "iは#{i}"
    p "ansは#{ans}"
    p "------"
  end

  i = i * i % m
  
  p "nは#{n}"
  p "iは#{i}"
    
  n >>= 1
  
  p "nは#{n}"
  p "-----------"
end

puts ans