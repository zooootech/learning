# 規則的な数列の和 (paizaランク C 相当)
# https://paiza.jp/works/mondai/a_rank_level_up_problems/a_rank_calculation_exchange_700

# 素直に繰り返しで A の要素の足し算を行おうとすると、最大 10 ^ 12 回ループが回ることになってしまい、実行制限時間に間に合いません。そこで計算の工夫を行います。
# 数列 A の規則性に注目します。 A の連続する 3 つの要素の和は必ず 0 になります。そのため、N 項目から 3 要素ずつ区切っていき、最後に残った要素の和が答えとなります。
# 最後に残る要素は 0 要素 〜 2 要素であり、その要素は N , K を 3 で割った余り（剰余）によって定まるので、N%3 , K%3 について場合分けを行うことで答えを求めることができます。


# A = [1, 0, -1, 1, 0, -1, ...]

n, k = gets.chomp.split.map(&:to_i)

sum = 0  # 5 / 9 の確率で答えは 0 になる

# 開始地点 n に対する終了地点 k で場合分け
if n % 3 == 0  # 3 の倍数（n % 3 == 0）の位置にある要素は -1 なので、この時点で sum は -1
  # n 項目から 3 要素区切りで、 k 項目が一つ右隣の要素の場合から考える
  # k % 3 == 1 の場合、その位置にある要素は 1 で、 sum は -1 + 1 = 0
  # k % 3 == 2 の場合、その位置にある要素は 0 で、 sum は -1 + 1 + 0 = 0
  # k % 3 == 0 の場合、その位置にある要素は -1 で、 sum は -1 + 1 + 0 + (-1) = -1
  # 以上より、 sum の初期値を 0 に設定していることから、 k % 3 == 0 の場合分けのみ記述すれば良い
  if k % 3 == 0  
    sum = -1
  end
elsif n % 3 == 1  # n % 3 == 1 の位置にある要素は 1 なので、この時点で sum は 1
  # n 項目から 3 要素区切りで、 k 項目が一つ右隣の要素の場合から考える
  # k % 3 == 2 の場合、その位置にある要素は 0 で、 sum は 1 + 0 = 1
  # k % 3 == 0 の場合、その位置にある要素は -1 で、 sum は 1 + 0 + (-1) = 0
  # k % 3 == 1 の場合、その位置にある要素は 1 で、 sum は 1 + 0 + (-1) + 1 = 1
  # 以上より、 sum の初期値を 0 に設定していることから、 k % 3 != 0 の場合分けのみ記述すれば良い
  unless k % 3 == 0
    sum = 1
  end
else  # n % 3 == 2 の位置にある要素は 0 なので、この時点で sum は 0
  # n 項目から 3 要素区切りで、 k 項目が一つ右隣の要素の場合から考える
  # k % 3 == 0 の場合、その位置にある要素は -1 で、 sum は 0 + (-1) = -1
  # k % 3 == 1 の場合、その位置にある要素は 1 で、 sum は 0 + (-1) + 1 = 0
  # k % 3 == 2 の場合、その位置にある要素は 0 で、 sum は 0 + (-1) + 1 + 0 = 0
  # 以上より、 sum の初期値を 0 に設定していることから、 k % 3 == 0 の場合分けのみ記述すれば良い
  if k % 3 == 0
    sum = -1
  end
end

puts sum

# -------------------------------------------------

n, k = gets.chomp.split.map(&:to_i)

sum = 0

if n % 3 == 0
  if k % 3 == 0  
    sum = -1
  end
elsif n % 3 == 1
  if k % 3 != 0
    sum = 1
  end
else  # n % 3 == 2
  if k % 3 == 0
    sum = -1
  end
end

puts sum