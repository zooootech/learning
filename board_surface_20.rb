# 陣取りの結末 (paizaランク B 相当)
# https://paiza.jp/works/mondai/a_rank_level_up_problems/a_rank_camp_step3

# 基本的な考え方は以下のヒントの通りです。
# ヒント：プレイヤーは現在の陣地から １ マス移動することで到達できるマスをプレイヤーの陣地にする。
# この操作を、繰り返すことで陣地の拡大を実装してみましょう。
# 具体的な処理の流れは次の通りです。
# プレイヤーのいるマスから１マス拡大 → 1 回目の拡大で新たに陣地になったマス 1 → 1 回目の拡大で新たに陣地になったマス ２ ....
# このアルゴリズムを 幅優先探索 といいます。
# moveに渡す引数の管理はキューなどの FIFO(First In First Out, 先に入ったものが先に出てくること) のデータ構造を用いるとうまくいきます。

# 初めにスタート地点の座標をキューに入れ、隣接する移動可能なマスの座標をqueueに入れます。 例. 上下左右のマスに移動可能な場合、（移動可能なマスの座標を 1, 2, 3, 4 と表現する） queue の先頭 ← 1, 2, 3, 4 → queue の末尾
# queue からマスを １ つ取り出し、まだ陣地でない部分を新たに陣地にします。 例. マス 1 から移動可能なマスが 3 つの場合、（移動可能なマスの座標を 5, 6, 7 と表現する） queue の先頭 ← 2, 3, 4, 5, 6, 7 → queue の末尾
# これを queue に入れた順に １ マスずつ行っていき、できなくなるまで進めます。
# 一度陣地にしたマスは必ず * になるため、同じマスが queue に 2 回入ることはなく、ループはマスの数だけしか回らないので、 この幅優先探索の計算量は O(HW) になります。


h, w = gets.chomp.split.map(&:to_i)

array = []

for i in 1..h
  array << gets.chomp
end

# このコードでは my_p をキューとして使います。
my_p = []

# まず最初に * の位置を my_p に追加します。
for y in 0..(h - 1)
  for x in 0..(w - 1)
    if array[y][x] == "*"
      my_p.push([y, x])  # 最初の位置を配列 my_p に追加
    end
  end
end

# my_p から座標を取り出し、上下左右を確認し移動出来るようならマスを * に書き換え、移動先の座標(y, x の組み合わせ)を my_p の末尾に追加します。
# この処理を my_p の中身が空になるまでループします。

while my_p.size != 0  # 配列 my_p の要素がなくなるまで繰り返し処理を行う
  # 配列.delete_at(pos)で、指定された位置 pos にある要素を取り除きそれを返します。 pos が範囲外であったら nil を返します。
  # Array#at と同様に負のインデックスで末尾から位置を指定することができます。
  # 二次元配列 my_p からインデックス（添字）が 0 の要素 を取り除き、その要素（2 つの要素を持つ配列）の要素をそれぞれ x, y に代入する
  y, x = my_p.delete_at(0)

  if 0 < y && array[y - 1][x] == "."
    array[y - 1][x] = "*"
    my_p.push([y - 1, x])
  end
  if y < h - 1 && array[y + 1][x] == "."
    array[y + 1][x] = "*"
    my_p.push([y + 1, x])
  end
  if 0 < x && array[y][x - 1] == "."
    array[y][x - 1] = "*"
    my_p.push([y, x - 1])
  end
  if x < w - 1 && array[y][x + 1] == "."
    array[y][x + 1] = "*"
    my_p.push([y, x + 1])
  end
end

array.each do |row|
  puts row
end